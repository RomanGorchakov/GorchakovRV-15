# Отчет по лабораторной работе №5
# Надежность: Журнал предзаписи (WAL)

## Сведения о студенте
**Дата:** [2004-11-15]

**Семестр:** 7

**Группа:** ПИЖ-б-о-22-1

**Дисциплина:** Администрирование баз данных

**Студент:** Горчаков Роман Владимирович

## Цель работы
Изучить работу буферного кеша и механизма журналирования предзаписи (WAL) в PostgreSQL.

Получить практические навыки управления контрольными точками, анализа журнальных записей, настройки параметров WAL и исследования процессов восстановления после сбоев.

## Теоретическая часть
### Изученные концепции
- Грязные буферы: буферы в буферном кэше, которые содержат изменённые данные на странице. Такой буфер помечается специальным флагом в заголовке, и данные на странице рано или поздно должны быть записаны на диск.
- WAL-записи: записи журнала WAL. Они фиксируют все изменения данных перед их записью на диск, что обеспечивает возможность восстановления согласованности данных после сбоя.

### Ключевые термины
- **Буферный кэш:** область общей памяти для кэширования страниц данных, считываемых с диска. Изменённые ("грязные") буферы периодически сбрасываются на диск.
- **Контрольная точка (Checkpoint):** процесс принудительной записи всех "грязных" буферов на диск. Ограничивает объем WAL, необходимый для восстановления.
- **Журнал предзаписи (WAL):** циклический журнал, в который записываются все изменения данных перед тем, как они попадут в основные файлы данных. Обеспечивает надежность и возможность восстановления после сбоя.
- **Восстановление:** процесс применения WAL-записей, созданных после последней контрольной точки, к данным на диске для приведения их в согласованное состояние.

## Практическая часть

### Модуль 1: Процессы и режимы остановки

#### Задача 1: Поиск процессов
**Цель:** Средствами ОС (например, ps aux | grep postgres) найти процессы, отвечающие за работу буферного кеша (checkpointer, background writer) и журнала WAL (walwriter).

**Выполненные действия:**

ps aux | grep postgres

**Результаты:**

postgres     836  0.0  3.1 225452 30988 ?        Ss   17:16   0:00 /usr/lib/postgresql/16/bin/postgres -D /var/lib/postgresql/16/main -c config_file=/etc/postgresql/16/main/postgresql.conf

postgres     845  0.0  1.0 225584 10336 ?        Ss   17:16   0:00 postgres: 16/main: checkpointer 

postgres     846  0.0  0.7 225608  7528 ?        Ss   17:16   0:00 postgres: 16/main: background writer 

postgres     877  0.0  1.0 225452 10252 ?        Ss   17:16   0:00 postgres: 16/main: walwriter 

#### Задача 2: Остановка Fast
**Цель:** Остановить PostgreSQL в режиме fast (sudo pg_ctlcluster 16 main stop), запустить сервер, просмотреть журнал сообщений сервера (/var/log/postgresql/postgresql-16-main.log), и найти записи о контрольной точке, выполненной при завершении работы.

**Выполненные действия:**
1. sudo pg_ctlcluster 16 main stop
2. sudo pg_ctlcluster 16 main start
3. sudo tail -f /var/log/postgresql/postgresql-16-main.log

**Результаты:**

3. 

2025-11-17 02:12:46.620 MSK [807] LOG:  background worker "logical replication launcher" (PID 890) exited with exit code 1

2025-11-17 02:12:46.621 MSK [831] LOG:  shutting down

2025-11-17 02:12:46.626 MSK [831] LOG:  checkpoint starting: shutdown immediate

2025-11-17 02:12:46.636 MSK [831] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.001 s, total=0.014 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=0 kB; lsn=0/CD9F2C8, redo lsn=0/CD9F2C8

2025-11-17 02:12:46.638 MSK [807] LOG:  database system is shut down

2025-11-17 02:13:01.476 MSK [1352] LOG:  starting PostgreSQL 16.10 (Ubuntu 16.10-1.pgdg24.04+1) on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, 64-bit

2025-11-17 02:13:01.477 MSK [1352] LOG:  listening on IPv4 address "127.0.0.1", port 5432

2025-11-17 02:13:01.481 MSK [1352] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"

2025-11-17 02:13:01.491 MSK [1355] LOG:  database system was shut down at 2025-11-17 02:12:46 MSK

2025-11-17 02:13:01.500 MSK [1352] LOG:  database system is ready to accept connections

#### Задача 3: Остановка Immediate
**Цель:** Остановить PostgreSQL в режиме immediate (sudo pg_ctlcluster 16 main stop -m immediate), запустить сервер, просмотреть журнал сообщений, найти записи о восстановлении после сбоя (recovery) и сравнить с предыдущим случаем.

**Выполненные действия:**

1. sudo pg_ctlcluster 16 main stop -m immediate
2. sudo pg_ctlcluster 16 main start
3. sudo tail -f /var/log/postgresql/postgresql-16-main.log

**Результаты:**

3.

2025-11-17 02:20:06.708 MSK [1418] LOG:  checkpoint starting: shutdown immediate

2025-11-17 02:20:06.723 MSK [1418] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.004 s, sync=0.002 s, total=0.019 s; sync files=2, longest=0.001 s, average=0.001 s; distance=0 kB, estimate=0 kB; lsn=0/CD9F428, redo lsn=0/CD9F428

2025-11-17 02:20:06.726 MSK [1417] LOG:  database system is shut down

2025-11-17 02:20:09.028 MSK [1485] LOG:  starting PostgreSQL 16.10 (Ubuntu 16.10-1.pgdg24.04+1) on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, 64-bit

2025-11-17 02:20:09.028 MSK [1485] LOG:  listening on IPv4 address "127.0.0.1", port 5432

2025-11-17 02:20:09.030 MSK [1485] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"

2025-11-17 02:20:09.041 MSK [1488] LOG:  database system was shut down at 2025-11-17 02:20:06 MSK

2025-11-17 02:20:09.047 MSK [1485] LOG:  database system is ready to accept connections

2025-11-17 02:25:09.140 MSK [1486] LOG:  checkpoint starting: time

2025-11-17 02:25:09.166 MSK [1486] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.007 s, sync=0.004 s, total=0.026 s; sync files=2, longest=0.003 s, average=0.002 s; distance=0 kB, estimate=0 kB; lsn=0/CD9F510, redo lsn=0/CD9F4D8

**Выводы и объяснения:**
Режим fast выполняет штатную, быструю остановку. Он дожидается завершения активных транзакций и корректно сбрасывает все данные на диск. Следующий запуск происходит быстро и без дополнительных процедур. Режим immediate, по сути, имитирует сбой питания или "убийство" процесса (kill -9). Он обрывает все соединения и процессы без ожидания.

### Модуль 2: Буферный кеш и контрольные точки

#### Задача 1: Анализ размера
**Цель:** Создать таблицу wal_test (id INT, data TEXT), вставить в неё достаточное количество строк. Определите, сколько страниц на диске занимает таблица (например, с помощью pg_relation_size(...) / current_setting('block_size')::int). Определите, сколько буферов занимает таблица в кеше (запрос к pg_buffercache).

**Выполненные действия:**
1. create extension pg_buffercache;
2. create table wal_test (id int, data text);

3. 
DO $$
BEGIN
    FOR i IN 1..100000 LOOP
        insert into wal_test (id, data) values (i, 'Это тестовая строка данных номер ' || i || ' ' || md5(random()::text));
    END LOOP;
END $$;

4. select count(*) from wal_test;
5. select pg_relation_size('wal_test') as size_in_bytes, current_setting('block_size')::int as block_size, pg_relation_size('wal_test') / current_setting('block_size')::int as pages_on_disk;
6. select count(*) AS buffers_in_cache from pg_buffercache b join pg_class c on b.relfilenode = c.relfilenode where c.relname = 'wal_test';

**Результаты:**
1. CREATE EXTENSION
2. CREATE TABLE
3. DO

4. 
 count  

--------

 100000

(1 row)

5. 
 size_in_bytes | block_size | pages_on_disk 

---------------+------------+---------------

      13434880 |       8192 |          1640

(1 row)

6. 
 buffers_in_cache 

------------------

             1644

(1 row)

#### Задача 2: Грязные буферы и контрольная точка
**Цель:** Узнать общее количество "грязных" буферов в кеше (запрос к pg_stat_bgwriter или pg_buffercache), выполнить команду CHECKPOINT; снова проверить количество "грязных" буферов и объяснить результат.

**Выполненные действия:**
1. create table test_checkpoint (id serial primary key, data text);
2. insert into test_checkpoint (data) select 'value-' || g from generate_series(1, 10000) g;
3. update test_checkpoint set data = data || ' (updated)';
4. select count(*) as dirty_buffers from pg_buffercache where isdirty;
5. checkpoint;
6. select count(*) as dirty_buffers from pg_buffercache where isdirty;
7. select lp, t_ctid, t_data, t_xmin, t_xmax, (t_infomask & 256) > 0 as tuple_is_hot_updated from heap_page_items(get_raw_page('hot_test', 0));
8. select ctid from bt_page_items('hot_test_pkey', 1);

**Результаты:**
1. CREATE TABLE
2. INSERT 0 10000
3. UPDATE 10000

4. 
 dirty_buffers 

---------------

           415

(1 row)


5. CHECKPOINT

6. 
 dirty_buffers 

---------------

             0

(1 row)

**Выводы и объяснения:**
UPDATE изменил данные в кэше в оперативной памяти. PostgreSQL не пишет каждое изменение сразу на диск для максимальной производительности. Поэтому в pg_buffercache мы увидели ненулевое количество буферов с флагом isdirty = true. Команда CHECKPOINT инициировала процесс, который нашел все "грязные" буферы в кэше и принудительно записал их содержимое в соответствующие файлы данных на диске. Как только данные из буфера успешно записаны на диск, он перестает считаться "грязным". Его флаг isdirty сбрасывается в false. Поэтому наш второй запрос показал 0. Данные в памяти теперь полностью соответствуют данным на диске (на момент начала контрольной точки).

#### Задача 3: Предварительное чтение (pg_prewarm)
**Цель:** Подключить расширение pg_prewarm, загрузить свою таблицу в кеш с помощью pg_prewarm(...), перезапустить сервер, проверить, осталась ли таблица в кеше, и проанализировать эффективность метода.

**Выполненные действия:**
1. create extension pg_prewarm;
2. create table big_table (id int primary key, data text, num_val numeric);
3. insert into big_table (id, data, num_val) select i, md5(random()::text), random() * 1000 from generate_series(1, 1000000) as i;
4. create index idx_big_table_data on big_table(data);
5. analyze big_table;
6. select pg_size_pretty(pg_total_relation_size('big_table'));
7. select c.relname, count(*) as buffered_blocks from pg_buffercache b join pg_class c on b.relfilenode = pg_relation_filenode(c.oid) where c.relname in ('big_table', 'idx_big_table_data') group by c.relname;
8. select pg_prewarm('big_table', 'buffer');
9. select c.relname, count(*) as buffered_blocks from pg_buffercache b join pg_class c on b.relfilenode = pg_relation_filenode(c.oid) where c.relname IN ('big_table', 'idx_big_table_data') group by c.relname;
10. sudo systemctl restart postgresql
11. select c.relname, count(*) as buffered_blocks from pg_buffercache b join pg_class c on b.relfilenode = pg_relation_filenode(c.oid) where c.relname IN ('big_table', 'idx_big_table_data') group by c.relname;

**Результаты:**
1. CREATE EXTENSION
2. CREATE TABLE
3. INSERT 0 1000000
4. CREATE INDEX
5. ANALYZE

6. 
 pg_size_pretty 

----------------

 152 MB

(1 row)

7. 
  relname  | buffered_blocks 

-----------+-----------------

 big_table |            9442

(1 row)

8. 
 pg_prewarm 

------------

       9436

(1 row)

9. 
  relname  | buffered_blocks 

-----------+-----------------

 big_table |            9442

(1 row)

11. 
 relname | buffered_blocks 

---------+-----------------

(0 rows)

**Выводы и объяснения:**
Эффективность ручного вызова после перезапуска сводится к тому, что данные остаются в кеше операционной системы, что всё равно ускоряет первое чтение.

## Результаты выполнения

### Сводная таблица результатов
| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1 | ✅ Выполнено | Средствами ОС можно найти процессы, отвечающие за работу буферного кеша и журнала WAL |
| 1 | 2 | ✅ Выполнено | Режим fast дожидается завершения всех транзакций, прежде чем остановить PostgreSQL |
| 1 | 3 | ✅ Выполнено | Режим immediate принудительно останавливает PostgreSQL, не дожидаясь завершения всех транзакций |
| 2 | 1 | ✅ Выполнено | pg_buffercache позволяет определить, сколько буферов заполняет таблица в кэше |
| 2 | 2 | ✅ Выполнено | pg_buffercache позволяет определить общее количество "грязных" буферов, а команда CHECKPOINT уменьшает их число до нуля |
| 2 | 3 | ✅ Выполнено | pg_prewarm позволяет загружать таблицы в кэш |

## Анализ и выводы

### Основные наблюдения
1. pg_prewarm - это расширение, которое позволяет предварительно загружать данные отношений в буферный кэш или кеш операционной системы.
2. full_page_writes - это параметр, который записывает в журнал WAL всё содержимое каждой страницы при первом изменении этой страницы после контрольной точки.
3. wal_compression - это параметр конфигурации, который включает сжатие сегментов журнала WAL.